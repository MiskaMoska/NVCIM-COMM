
import networkx as nx
from typing import Dict, List, Any, Tuple, Mapping
from maptools.core import MeshEdge, Connection, ACG, RouterPort, PhysicalTile
from maptools.nlrt import RoutingTrail

class RoutingConfigurator(object):

    # number of router input/output ports
    N_PORT = 5

    # input port name --> port ID mapping
    IP_MAP = {
        RouterPort.LOCAL_I      : 0,
        RouterPort.WEST_I       : 1,
        RouterPort.EAST_I       : 2,
        RouterPort.NORTH_I      : 3,
        RouterPort.SOUTH_I      : 4
    }

    # output port name --> port ID mapping
    OP_MAP = {
        RouterPort.LOCAL_O      : 0,
        RouterPort.WEST_O       : 1,
        RouterPort.EAST_O       : 2,
        RouterPort.NORTH_O      : 3,
        RouterPort.SOUTH_O      : 4
    }

    def __init__(
        self,
        cast_trails: Mapping[Connection, RoutingTrail],
        merge_trails: Mapping[Connection, RoutingTrail],
        acg: ACG
    ) -> None:
        '''
        This class generated the NoC routing configuration information
        according to cast trails and merge trails generated by `NocMapper`.

        Parameters
        ----------
        sid: int
            stream ID of the connection.

        cast_trails: Mapping[Connection, RoutingTrail]
            all cast trails with the connection name as keys and the routing trail as values.

        merge_trails: Mapping[Connection, RoutingTrail]
            all merge trails with the connection name as keys and the routing trail as values.

        acg: ACG
            architecture characterization graph.

        Key Members
        -----------
        self._crt: Mapping[PhysicalTile, List[List[List[int]]]]
            Mapping[Key=(x, y), Value=Array[N_PORT] [N_VC] [N_PORT]]
            each element is either 1 or 0, indicating whether the corresponding output port is 
            requested or not.  
        
        self._mrt: Mapping[PhysicalTile, Dict[str, List[int]]]
            Mapping[Key=(x, y), Value=router configuration dictionary]

            Where the router configuration dictionary follows the structure:
            Dict[Key='input_mask' or 'output_sel', Value=Array[N_PORT]]

            For example, if
            self._mr[(3, 5)] = {'input_mask': [1, 0, 1, 0, 1], 'output_sel': [0, 1, 0, 0, 0]}
            it means the local, east, and south input ports merges data to the west output port at router (3, 5)
        '''
        self._cast_trails = cast_trails
        self._merge_trails = merge_trails
        self._w = acg.w
        self._h = acg.h
        self._minvc: int
        self._cvmap: Mapping[Connection, int]

    def vc_assignment(self) -> None:
        '''
        This method assigns VCs to each cast connection,
        the connection --> VC mapping information is written to `self._cvmap`
        '''
        # constructing communication confliction dictionary
        confliction_dict: Mapping[MeshEdge, List[Connection]] = {}
        for conn, trail in self._cast_trails.items():
            for edge in trail.path:
                if edge not in confliction_dict:
                    confliction_dict[edge] = []
                confliction_dict[edge].append(conn)

        graph_list = []
        for connections in confliction_dict.values():
            graph_list.append(nx.complete_graph(connections))

        # constructing communication confliction graph
        confliction_graph = nx.compose_all(graph_list)
        self._cvmap: Mapping[Connection, int] = nx.greedy_color(confliction_graph)

        # calculate the maximum confliction and the minimum VC
        max_confliction = max([len(c) for c in confliction_dict.values()])
        self._minvc = len(set(list(self._cvmap.values())))
        print('max confliction:', max_confliction, 'min vc:', self._minvc)

    def gen_crt(self) -> Mapping[PhysicalTile, List[List[List[int]]]]:
        '''
        This method generates the cast routing tables, which is then stored in `self._crt`.
        '''
        self.vc_assignment()
        self._crt = {(x, y): [[[0 for _ in range(self.N_PORT)] 
                        for _ in range(self._minvc)] 
                        for _ in range(self.N_PORT)]
                        for x in range(self._w) for y in range(self._h)}

        for conn, trail in self._cast_trails.items():
            for src, dst in trail.cast_transitions:
                if src[0] != dst[0] or src[1] != dst[1]:
                    raise AssertionError(
                        "the intra-router transition donnot share the same router ID")
                self._crt[src[0:2]] [self.IP_MAP[src[2]]] [self._cvmap[conn]] [self.OP_MAP[dst[2]]] = 1
                
        return self._crt
    
    def gen_mrt(self) -> Mapping[PhysicalTile, Dict[str, List[int]]]:
        '''
        This method generates the merge routing tables, which is then stored in `self._mrt`.
        '''
        g = nx.DiGraph()
        self._mrt = {}
        g.add_nodes_from([(x, y) for x in range(self._w) for y in range(self._h)])
        merge_nodes = [trail.dst[0] for trail in self._merge_trails.values()]

        for trail in self._merge_trails.values():
            g.add_edges_from(trail.path)

        for node in g.nodes:
            x = node[0]
            y = node[1]
            neigh_nodes = [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]
            input_mask = []
            output_sel = []
            if node not in merge_nodes:
                input_mask.append(1) # non-merge node has local input
                output_sel.append(0) # non-merge node has no local output
            else:
                input_mask.append(0) # merge node has no local input
                output_sel.append(1) # merge node has local output

            for neigh_node in neigh_nodes:
                if neigh_node in g.predecessors(node):
                    input_mask.append(1)
                else:
                    input_mask.append(0)
                if neigh_node in g.successors(node):
                    output_sel.append(1)
                else:
                    output_sel.append(0)
            self._mrt[node] = {'input_mask': input_mask, 'output_sel': output_sel}

        return self._mrt
